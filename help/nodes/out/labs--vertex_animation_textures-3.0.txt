= Labs Vertex Animation Textures =

#type: node
#context: out
#internal: labs::vertex_animation_textures::3.0
#icon: vertexanimationtextures
#tags: sidefxlabs, gamedev 

""" The Vertex Animation Textures ROP will export a mesh and a set of textures to be used with a real-time shader to achieve complex effects, such as: soft-body deformation, rigid-body dynamics, dynamic remeshing, and particle sprites. """

Vertex Animation Textures (VAT) is an efficient and powerful method to recreate complex and non-traditional animations in real time. Because VAT only uses shaders and textures to achieve the visuals on GPU, it has a much lighter performance impact on the CPU, compared to traditional skeletal mesh animations. This also makes VAT a good candidate to individually animate a large number of instanced meshes. 

Furthermore, VAT comes in handy when a skeletal animation rig is too complicated to be imported to the real-time engine or used as it is. You can import the rig into Houdini and directly export the animated geometry through VAT, because all VAT needs is the points/vertices and the data on them on each frame.

Vertex animations encoded in textures do not have to be played in complete loops. You can start and stop at any frame because you directly control which frame to display at any given moment.

The limitations of VAT include: texture memory budget on lower-end hardwares, the lack of animated real-time collisions, and (often) the lack of per-vertex motion blur.

VAT 3.0 offers more streamlined workflows, additional advanced features, and a lot more customizability and extendability.


@parameters
    Render All:
        Cooks all dependent networks and renders all the assets specified on the Export tab.
    Mode / Target Engine:
        Mode depends on what kind of animation you want to export. Target Engine affects the coordinate system, the scale, and potentially some other engine specific parameters. See the information on the Input tab on how to prepare your input geometry for a specific mode and engine combination.
        <p>*Soft-Body Deformation (Soft)*: the surfaces have consistent topologies; they simple deform.</p>
        <p>*Rigid-Body Dynamics (Rigid)*: packed pieces with RBD simulation data.</p>
        <p>*Dynamic Remeshing (Fluid)*: the surfaces are potentially remeshed every frame with dynamic topologies.</p>
        <p>*Particle Sprites (Sprite)*: points with particle simulation data.</p>
    Start/End:
        The first frame and last frame of the animation to export. Both ends are inclusive.
    Input Geometry:
        The path to the geometry node that you want to render.
    ==Settings: Soft-Body Deformation==
    Validate Point Count Consistency:
        Checks if the input point count is consistent. If it is not, displays an error message. If you know your input geometry has consistent point count, you can turn this off to slightly reduce the cooking time.
    Export Compressed Normals in Position Alpha:
        Compresses the normals from the vector type to the float type and stores them in Position Texture's alpha channel. This is a lossy compression resulting in medium-quality normals. If you do not plan to apply regular (tangent-space) surface normal maps to your real-time asset, this is a more memory-efficient alternative as it bypasses the cost of sampling Rotation Texture. But if you want to apply regular normal maps, turn this off and use Rotation Texture instead. Turning this on also precludes you from exporting a custom attribute through Position Texture's alpha channel.
    ==Settings: Rigid-Body Dynamics==
    Pivot Accuracy:
        The vertices on every rigid-body piece are transformed relative to the piece's pivot. Therefore the accuracy of the pivot encoding determines the accuracy of piece translations and rotations throughout the animation.
        <p>*High*: select this if your vertex shader is a performance bottleneck; uses two 16-bit UV channels to store unencoded pivots; the overall cheapest option.</p> 
        <p>*Very High*: recommended; uses two 16-bit UV channels to store encoded pivots; deploys two split-encoding formats and dynamically pick the better format for each piece, producing an accuracy very close to that of "Maximum" at only half of the latter's memory footprint; costs more vertex shader instructions.</p>
        <p>*Maximum*: select this only if you absolutely need the highest possible accuracy; uses two 32-bit UV channels to store unencoded pivots; in Unreal Engine, you have to turn on *Use Full Precision UVs* in Mesh Editor, otherwise the actual accuracy is slightly worse than "High". Because Rigid-Body Dynamics (Rigid) mode requires 4-6 UV channels on the exported mesh, turning on Use Full Precision UVs doubles the memory footprints for all of them.</p>
    Rotation Interpolation:
        Select "Accurate Multi-RPF Slerp with Angular Velocity" unless your input geometry cannot provide the angular velocity attribute "w". If your input geometry comes from a RBD simulation, angular velocity is directly available. Simply make sure the attribute is included in the simulation output attributes and that it is transferred to points.
        <p>*Accurate Multi-RPF Slerp with Angular Velocity*: uses an angular-velocity-assisted spherical linear interpolation (slerp) algorithm to fairly accurately interpolate rotations of fast-spinning pieces; capable of interpolating pieces that spin much faster than 360 degrees per integer frame (multi-revolutions per frame); also capable of handling the edge case where a piece rotates to the exact same orientation as that of the previous frame; allows you to freely dilate time in real-time playbacks.</p>
        <p>*Basic Short-Path Slerp without Angular Velocity*: uses the standard short-path spherical linear interpolation (slerp) algorithm that does not require the input angular velocity; this limits accurate rotation interpolations to pieces that spin less than 180 degrees per inter frame; when any piece spins faster than that, its interpolation will be incorrect.</p>
    Slerp Edge Case Offset:
        Helps to resolve the edge case where a piece rotates to the exact same orientation as that of the previous frame. The slerp function is not defined for rotations that are exact multiples of 360 degrees. The solution is therefore to slightly rotate any edge-case piece towards or away from its next frame's orientation. On even frames, it will rotate forward in time by a random degree between 50% and 150% the value of this parameter; on odd frames, it will rotate backward in time by a random degree between -50% and -150% the value of this parameter. Do not set this parameter too small, or the real-time shader may suffer from numerical errors.
    Slerp Edge Case Seed:
        A global random seed that contributes to (but not solely responsible for) generating random degrees by which to rotate edge-case pieces (see the tooltip of Slerp Edge Case Offset). It is extremely unlikely that you will need to change this parameter. Only change it if the node displays an error message that asks you to do so.
    ==Settings: Dynamic Remeshing==
    Fuse Distance:
        Fuses together points within this distance to one another in the input geometry. This helps to remove tiny triangles that are a waste of resources and potentially problematic.
    Smooth Normals:
        Averages vertex normals to points, which produces smoother normals. Turn this off to keep the original vertex normals, which helps you preserve hard edges.
    Export Compressed Normals in Position Alpha:
        Compresses the normals from the vector type to the float type and stores them in Position Texture's alpha channel. This is a lossy compression resulting in medium-quality normals. If you do not plan to apply regular (tangent-space) surface normal maps to your real-time asset, this is a more memory-efficient alternative as it bypasses the cost of sampling Rotation Texture. But if you want to apply regular normal maps, turn this off and use Rotation Texture instead. Turning this on also precludes you from exporting a custom attribute through Position Texture's alpha channel.
    Export Fluid UVs in Position Alpha and Color Alpha:
        Exports the animated UV attributes through Position Texture's alpha channel and Color Texture's alpha channel. Dynamic Remeshing (Fluid) mode can support UV maps, but since the topology is dynamic, the input geometry has to be UV unwrapped on every frame. You can either UV unwrap the input geometry yourself (recommended) or rely on the auto UV generation method specified on the Input tab.
    Export Fluid UVs in Color Red and Green:
        Exports the animated UV attributes through Color Texture's red and green channels. Dynamic Remeshing (Fluid) mode can support UV maps, but since the topology is dynamic, the input geometry has to be UV unwrapped on every frame. You can either UV unwrap the input geometry yourself (recommended) or rely on the auto UV generation method specified on the Input tab.
    ==Settings: Particle Sprites==
    Support Particle Interframe Interpolation:
        Changes how the data are arranged on the output textures to make it possible to interpolate particle attributes in real time. This requires the input geometry to have the point attribute "id".
    Card Shape:
        Set the shape of the particle card geometry. Different shapes have slightly different performance impacts. But all shapes share the same centre in UV space.
    Square Orientation:
        How the square particle cards will be oriented in UV space and real-time view space.
    Triangle Orientation:
        How the triangular particle cards will be oriented in UV space and real-time view space.
    Hexagon Orientation:
        How the hexagonal particle cards will be oriented in UV space and real-time view space.
    Custom ZX Shapes:
        Replaces the default shape options with your own designs. The custom shape geometry has to be flat on the ZX plane. You can merge multiple shape variants together and point this parameter to the path of the combined geometry. See the tooltip of Multiple Shape Variants with Shape ID Attribute.
    Shape Input Type:
        The custom shapes can either be filled polygons or simply outlines defined by closed curves with no interiors. The hollow outlines will be automatically filled. For performance reasons, consider using a Fuse SOP to reduce the number of points used to define the input custom shapes.
    Multiple Shape Variants with Shape ID Attribute:
        When you merge multiple shape variants together (because Custom ZX Shapes only accepts one geometry path), they can still be uniquely identified if you assign each shape a unique shape ID value.
    Shape ID Attribute:
        A point or primitive integer attribute to distinguish different shape variants.
    Shape Weight Attribute:
        A point or primitive float attribute to determine the distribution of the shape variants. Each variant's likelihood of adoption by a particle is this variant's weight divided by the aggregate weight of all variants.
    Preserve Relative Scales of Different Shapes:
        Preserves the relative scale differences between multiple variants. Turn this off if you want to scale (the width-to-height ratio will be locked) different shape variants to have the same bounding square size.
    Reverse Custom Card Normals:
        Turn this on only if the particle cards have the wrong normals in your real-time engine, in which case, they may appear to be invisible but if you select the object, you can see the outlines. This is unlikely to happen, however.
    ==Settings: All Modes==
    Texture Format:
        Select "HDR" if your performance budget can afford it, because it offers better precision for all the data you are exporting. Only EXR and TIFF extensions can support HDR, but all extensions can support non-HDR. If your animation spans a huge area, the data precision will be pushed to its limit and non-HDR formats may result in noticeable issues; consider switching to HDR formats or dividing the animation into several smaller local parts. In your real-time engine, match the texture compression setting with this setting (see the tooltip of Pad Texture Size to Powers of Two for an exception).
    Split Positions into Two Textures:
        Uses two 8-bit textures for better precision when the target engine does not support 16/32-bit HDR textures. You must use both textures when this is turned on. The node automatically prevents you from accessing this option if you want to use a HDR Position Texture, but you can override this restriction in the Advanced tab.
    Export Spare Color Texture:
        Spare Color Texture exports the point vector attribute "Cd2" and the point float attribute "Alpha2" on the input geometry. It is useful when you want to export a second set of animated colors. You can also use it to export the actual colors when Color Texture is occupied by non-color data. Color Texture is designed to be a multi-purpose texture whereas Spare Color Texture is more of a pure color texture. But of course, you can still write non-color data into "Cd2" and "Alpha2".
    Export Static Mesh Vertex Colors:
        To export vertex colors, create the attributes "Cd_v" and "Alpha_v" on vertices as opposed to points. This is to clearly differentiate between animated point/piece/particle colors, which are exported through the textures, and unchanging vertex colors, which are exported through the static mesh. Vertex colors can be used for masking and other purposes. Dynamic Remeshing (Fluid) mode does not have the concept of static vertex colors, since there is no consistent topology. Particle Sprites (Sprite) mode only exports static vertex colors if they exist on the geometry from Custom ZX Shapes.
    Include Hidden Debug Plane in Geometry:
        Prior to Vertex Animation Textures ROP 3.0, you needed to set a list of parameter values in the real-time shader. Those data are now embedded in the bounds of the static mesh and automatically derived at runtime. Turn this on to include a simple square in the exported static mesh to display the embedded data when the shader is in a debug mode. When the shader is not in the debug mode, the plane is not rendered and incurs next to no cost. This feature is currently only supported with Unreal Engine.
    In Position Alpha:
        A custom float attribute you want to export through Position Texture's alpha channel. This attribute can have any non-negative values, including values above 1.0, even when using non-HDR texture formats. But in order to support this, negative values are not allowed.
    In Color:
        A custom vector attribute you want to export through Color Texture's RGB channels. This attribute does not undergo any transform, conversion, or normalization. If the attribute has values outside the 0-1 range, set Texture Format to "HDR". If you have to use a non-HDR texture, you can pre-normalize the attributes in the input geometry and manually reverse the normalization in the real-time shader.
    In Color Alpha:
        A custom float attribute you want to export through Color Texture's alpha channels. This attribute does not undergo any transform, conversion, or normalization. If the attribute has values outside the 0-1 range, set Texture Format to "HDR". If you have to use a non-HDR texture, you can pre-normalize the attributes in the input geometry and manually reverse the normalization in the real-time shader.
    Target Texture Width:
        The target width of the output textures. If there are less data points per frame than this width, the output textures use the number of data points as their widths. The number of data points by mode: Soft-Body Deformation (Soft), the point count; Rigid-Body Dynamics (Rigid), the packed piece count; Dynamic Remeshing (Fluid), three times the maximum triangle count; Particle Sprites (Sprite), the maximum particle count.
    Preview Texture Size (Slow):
        Turn this on to interactively preview the output texture size. It is somewhat slow because every time you toggle this on or some upstream parameter updates, the node will need to recheck the input geometry on every frame of the export frame range. But once it is turned on, updating Target Texture Width will have instant feedback.
    Pad Texture Size to Powers of Two:
        You normally do not need to pad animation data textures to powers of two in dimensions, because as data textures, they should not be streamed. But if the target engine or hardware only accepts powers of two textures, turn this on. In Unreal Engine, always use the HDR compression setting with any power-of-two textures that have data in their alpha channels, even if you exported those textures in non-HDR formats.
    ==Input==
    NOTE:
        Follow the input requirement checklist, which is specific to the current mode and target engine. Expand Help to see more information.
    UV Generation:
        Even though the vertex attribute "uv" is listed as an optional attribute, it is required implicitly. The node simply auto-computes UVs if they are missing from the input geometry. When they are not missing, you still have the option to have this node recompute them for you, but that is a less transparent workflow. Consider using Labs Auto UV SOP when preparing the input geometry.
        <p>*UV Unwrap*: faster; many more disjoint UV islands; fewer rotated islands in the UV layout.</p>
        <p>*UV Autoseam and Flatten*: slower but generally better quality; fewer disjoint UV islands; more rotated islands in the UV layout.</p>
    Normal Generation:
        Even though the vertex attribute "N" is listed as an optional attribute, it is required implicitly. The node simply auto-computes normals if they are missing from the input geometry. When they are not missing, you still have the option to have this node recompute them for you, but that is a less transparent workflow.
        <p>*By Vertex Angle*: sets the internal Normal SOP to run on vertices with a Cusp Angle of 60 and a Weighting Method of "By Vertex Angle".</p>
        <p>*By Face Area*: sets the internal Normal SOP to run on vertices with a Cusp Angle of 60 and a Weighting Method of "By Face Area".</p>
    Tangent Generation:
        It is recommended to let the node recompute the tangent attribute "tangentu" for you using the MikkT method. The bi-tangent attribute "tangentv" is always recomputed to ensure consistency.
    ==Export==
    Export Path:
        The directory in which to export the files.
    Asset Name:
        The overall name of this art asset. The names of all exported files will begin with this string.
    Geometry Name Suffix:
        Appends a suffix to the static mesh's file name right before the extension. Starting with Vertex Animation Textures ROP 3.0, the default workflow does not require you to export any real-time data file that contains the frame count and the FPS. The frame count is embedded and automatically derived by the real-time shader. The FPS should not change very often, so it is assumed that it is easier for you to simply remember the FPS than to export it every time. But in case you prefer to keep a copy of those numbers somewhere, this gives you an option to append them to the geometry file name. An alternative option available in Unreal Engine is to enter the debug mode to see the frame count (see the tooltip of Include Hidden Debug Plane in Geometry).
    Include:
        Selects which of the following sets of files to render and export. Starting with Vertex Animation Textures ROP 3.0, Normal Texture is deprecated and replaced by Rotation Texture which describes both normals and tangents. Position Texture 2 and Spare Color Texture are not directly enabled/disabled here. They depend on parameters in the Settings tab. But you cannot export Position Texture 2 without Position Texture 1, and you cannot export Spare Color Texture without Color Texture.
    Geometry:
        The export path of the static mesh file.
    Position / Position 1:
        The export path of Position Texture.
    Position 2:
        The export path of Position Texture 2.
    Rotation:
        The export path of Rotation Texture.
    Color:
        The export path of Color Texture.
    Spare Color:
        The export path of Spare Color Texture. 
    Unity Material:
        The export path of Unity Material.
    Real-Time Data:
        The export path of Real-Time Data JSON file.
    ==Advanced==
    Live Update (Slow):
        Only useful when debugging or modifying this node. When this is turned on, any update to the input geometry, the node parameters, or internal networks may trigger a partial or full recook, depending on where the change is made.
    Do Not Reset Live Update After Render:
         Only useful when debugging or modifying this node. When you press Render All, the node automatically turns on Live Update to enable a full recook of the internal networks. After the renders are complete, the node automatically turns Live Update off, which you can prevent with this parameter. It is useful so you can keep debugging after the renders.
    Allow Splitting Positions into Two HDR Textures:
        Normally it is a waste of resources to use two HDR Position Textures, so the access to Split Position into Two Textures is restricted when Texture Format is set to "HDR". You can override that restriction with this parameter.
    Allow Exporting Real-Time Data JSON File (Legacy):
        Starting with Vertex Animation Textures 3.0, the default workflow does not require you to export any real-time data file. The long list of parameters used to be written to the data file in the older versions are now embedded in the bounds of the static mesh and automatically derived at runtime. However, you may still want to work with the legacy parameters in at least two situations:
        <p>1. you need to support real-time instancing; the instance transforms may corrupted the embedded data;</p>
        <p>2. you need to change the object's bound scale in engine, which may corrupt the embedded data; however, you should rarely have any reason to change the bound scale, because unlike prior versions, the bounds now encompass the full visible area of the animation, i.e., the mesh will not be incorrectly culled when you move the camera. In Unreal Engine, changing the actor/component scale is totally safe.</p>
    Support Real-Time Instancing:
        Turn this on if you need to support real-time instancing of your vertex-animated mesh.
    ==Advanced: Scripts==
    Initialize Simulation OPs:
        Force all simulation OPs to be reset before Pre-Render Script is executed. This is the safest way to render out a simulation, because it starts the simulation from scratch and discards any partial simulations you might have done with different parameters. However, throwing away an already-cooked simulation can be expensive, especially for relatively slow solvers such as fluids.
    Pre-Render Script:
        This script is executed before any rendering.
    Post-Render Script:
        This script is executed after all rendering.
    PDG Log Output:
        Prints output file paths with optional tags.
    ==Advanced: Developer Options==
    Convert to Image Format Colorspace:
        Image data in COPs is always linear. When writing to image formats that are not linear (sRGB, for example), this will convert the colorspace to preserve the look of the image. An 8-bit format that has an unspecified colorspace is assumed to be sRGB.
    Raster Depth:
        The byte format of the image. Higher bit depths provide better color resolution and range at the expense of memory.
        <p>*8 Bit Integer*: lowest bit depth; banding can occasionally be seen; suitable for video.</p>
        <p>*16 Bit Integer*: intermediate bit depth; no banding can be seen, though clipping can still occur below and above the black and white points.</p>
        <p>*32 Bit Integer*: generally not used for color, 32-bit integer values are used to store object IDs, counts, and other integer values with a large range.</p>
        <p>*16 Bit Floating Point*: high bit depth; no banding can be seen, and no clipping occurs at white and black; uses less memory than 32-bit float, however processing time for this format is slightly higher as it is not a native CPU data format; this format supports values in the range -65504 to +65504.</p>
        <p>*32 Bit Floating Point*: high bit depth; no banding can be seen, and no clipping occurs at white and black; uses 4 times as much memory as 8 bit, which is this format’s main drawback.</p>
    Black/White Points:
        The integer formats (8, 16 and 32 bit) can specify the raw values that the black and white points occur at. The white point must always be higher than the black point. The minimum and maximum values for the black and white points for each format are:
        <p>*8 bit*   :   0 - 255</p>
        <p>*16 bit*  :   0 - 65535</p>
        <p>*32 bit*  :   0 - 2,147,483,647</p>
        <p>Floating point formats always have their black point at 0 and their white point at 1.</p>
    BC 4-Channel Split:
        Renders the channels separately for different data formats.
    Render With Take:
        You can optionally turn this on if you are working with takes.
    ==Target Engine==
    Coordinate System:
        Set this to match the coordinate system of your custom engine. You first need to determine your engine's coordinate system. To use the clockwise rule, orient the axes so that all three positive directions are facing towards you; start from the up axis and count clockwise. To use the right/left-hand rule, take out the respective hand, extend the thumb and the index finger, and keep the middle finger perpendicular to the palm; the index finger points to +X, the middle finger +Y, and the thumb +Z.
    1 Metre in Engine Units:
        How many target engine units equal one real-world metre. This is used to determine the export conversion scale.
    ==Real-Time Shaders==
    Find Shaders For:
        Displays the shader resources for the selected engine.
    Unreal Engine Content Plugin and Guides:
        Press this button to go to the directory of SideFX Labs content plugin for Unreal Engine. Click on the folder matching the Unreal Engine version you need. Follow the guides inside. 
    Unity Package and Guides:
        Press this button to go to the directory of SideFX Labs Vertex Animation Textures package for Unity. Follow the guides inside.